# php-class-Err

Error handling class for PHP. Handles all errors generated by PHP and exceptions. Enables logging, custom error messages, production and development environments and instant feedback for development.

* [Quick set up](#quick-set-up)
* [Error types](#error-types)
* [Decoding errors](#decoding-errors)
* [Custom fatal actions](#custom-fatal-actions)
* [All valid options during initialisation](#all-valid-options-during-initialisation)
* [Extracting error data before shutdown](#extracting-error-data-before-shutdown)
* [Logging extra data](#logging-extra-data)

----


##Quick set up

Create a directory for the log file and add an empty file called *errors.txt*.

Initialise Err as early as possible and include the location of the log directory.

```php
include '/path/to/Err.php';

Err::initialise([
  'log_directory' => '/path/to/log/dir'
]);

```

If errors are recorded and need to be logged, the details are encoded as a JSON string and stored on an individual line in the log file.


##Error types

The class categorises PHP errors into three types: *minor*, *major* and *fatal*. 
* Minor errors are ignored (not logged) if no other error types occur
* If a major error occurs *all* errors are logged silently in the defined log file
* Any other error (fatal) causes the application to terminate, the final action depends on parameter settings

The class has default values which can be overwritten if needed. Only *minor* and *major* values are set, anything else is considered *fatal*.

Allowed values for *minor* and *major* are `E_WARNING`, `E_NOTICE`, `E_CORE_WARNING`, `E_COMPILE_WARNING`, `E_USER_WARNING`, `E_USER_NOTICE`, `E_STRICT`, `E_RECOVERABLE_ERROR`, `E_DEPRECATED` and `E_USER_DEPRECATED`. Any other constants submitted will result in an Exception being thrown.

Here is an example of initialisation including defining error types (this example sets the default values).

```php
include '/path/to/Err.php';

Err::initialise([
  'errors_major' => E_WARNING | E_CORE_WARNING | E_COMPILE_WARNING | E_USER_WARNING | E_DEPRECATED | E_USER_DEPRECATED,
  'errors_minor' => E_NOTICE | E_USER_NOTICE | E_STRICT,
  'log_directory' => '/path/to/log/dir'
]);

```

If an error is defined for both *minor* and *major*, the error will be treated as *minor*.


##Decoding errors

The class includes an error decoding method. It can be used as follows,

```php
$error_name = Err::getName($error_code);

```

For example,

```php
echo Err::getName(4); // E_PARSE

```

See http://php.net/manual/en/errorfunc.constants.php for complete listing of PHP's predefined error constants.


##Custom fatal actions

The class will perform one of three actions in the event of a fatal error. This is determinined by the mode.
* `Err::MODE_DEVELOPMENT` Error details are dumped to screen and not logged
* `Err::MODE_PRODUCTION` A generic error message is displayed and errors are logged
* `Err::MODE_SILENT` No output and errors are logged

Mode is set during initialisation, [see all initilisation options](#all-valid-options-during-initialisation).

Fatal actions can be customised by creating a separate class and defining them on initialisation. Do not forget to log any errors using `Err::logErrors()`.

```php
ErrFatalAction {
  /**
   * Method will be called the event of a fatal action when in development mode
   */
  public static function development()
  {
    // Get the error data
    $data = Err::extract(true);

    // Any extra log data is also available
    $extra_log_data = Err::getLogData();

    // A simple dump of the data
    echo '<hr>';
    echo '<h1>PHP fatal error</h1>';
    echo '<hr>';
    echo '<pre>';
    print_r($data['counts']);
    echo '</pre>';
    echo '<hr>';
    echo '<pre>';
    print_r($data['errors']);
    echo '</pre>';
  }

  /**
   * Method will run in the event of a fatal action when in production mode
   */
  public static function production()
  {
    Err::logErrors();
    echo '<h1>Sorry, an application error occurred</h1><hr><p>Details have been logged</p>';
  }
  
  /**
   * Method will run in the event of a fatal action when in silent mode
   */
  public static function silent()
  {
    Err::logErrors();
  }
}

```

Keep the methods as simple as possible, errors will not be logged or displayed if triggered within these methods. It may be helpful to begin each method with `error_reporting(E_ALL);` for debugging during method development.

Once the custom class has been written, details can be set on initialisation. 

```php
include '/path/to/Err.php';
include '/path/to/ErrFatalAction.php';

Err::initialise([
  'log_directory' => '/path/to/log/dir',
  'fatal_action_development' => 'ErrFatalAction::development',
  'fatal_action_production' => 'ErrFatalAction::production'
]);

```


##All valid options during initialisation

The following example shows initialisation with all valid options being set with their default values. The only required option is `log_directory`. The class will function with all other default values.


```php
Err::initialise([
  'errors_major' => E_WARNING | E_CORE_WARNING | E_COMPILE_WARNING | E_USER_WARNING | E_DEPRECATED | E_USER_DEPRECATED,
  'errors_minor' => E_NOTICE | E_USER_NOTICE | E_STRICT,
  'fatal_action_development' => null, // if null, class default action will be used
  'fatal_action_production' => null, // if null, class default action will be used
  'fatal_action_silent' => null, // if null, class default action will be used
  'log_data' => null, // can be an array of extra data, may also be set later using Err::addLogData()
  'log_directory' => '/path/to/log/dir',
  'log_file' => 'errors.txt',
  'mode' => Err::MODE_DEVELOPMENT,
  'timestamp' => date('r')
]);

```


##Extracting error data before shutdown

During development it may be useful to view errors immediately after each request runs so that it is not necessary to check the logs. It is possible to extract all error data at any point. This will return the error data as an array, all data that is returned will not be logged. For example,

```php
$error_data = Err::extract();

```

An example dump of `$error_data` is,

```
Array (
	[0] => Array (
		[type] => 0
		[code] => 8
		[message] => Undefined index: foo
		[file] => /var/www/html/example.php
		[line] => 21
		[backtrace] => Array (
			[0] => Array (
				[file] => /var/www/html/example.php
				[line] => 21
				[function] => errorHandler
				[class] => Err
 				[type] => ::
			)
		)
	)
)
```

You may also add `true` as an argument, 

```php
$error_data = Err::extract(true);

```

to get a little more detail,

```
Array (
	[counts] => Array (
		[minor] => 2
		[major] => 1
		[fatal] => 0
	)
	[errors] => Array (
		// array of error data as in the previous example
	)
)
```


##Logging extra data

It is possible to add extra data to the error logs for help with debugging. Extra log data can be added during initialisation or later on. Here's an example for adding extra log data later,

```php
Err::addLogData([
  'organisation_id' => $_SESSION['organisation_id'],
  'user_id' => $_SESSION['user_id']
]);

```

The Organisation ID and User ID will now be stored in the log. If a submitted key already exists, it will be overwritten. To retrieve extra log data use `Err::getLogData()`.
